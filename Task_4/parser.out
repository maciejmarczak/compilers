Created by PLY version 3.9 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> program_parts
Rule 2     program -> <empty>
Rule 3     program_parts -> program_parts program_part
Rule 4     program_parts -> program_part
Rule 5     program_part -> declaration
Rule 6     program_part -> instruction
Rule 7     program_part -> fundef
Rule 8     declarations -> declarations declaration
Rule 9     declarations -> <empty>
Rule 10    declaration -> TYPE inits ;
Rule 11    declaration -> error ;
Rule 12    inits -> inits , init
Rule 13    inits -> init
Rule 14    init -> ID = expression
Rule 15    instructions -> instructions instruction
Rule 16    instructions -> instruction
Rule 17    instruction -> print_instr
Rule 18    instruction -> labeled_instr
Rule 19    instruction -> assignment
Rule 20    instruction -> choice_instr
Rule 21    instruction -> while_instr
Rule 22    instruction -> repeat_instr
Rule 23    instruction -> return_instr
Rule 24    instruction -> break_instr
Rule 25    instruction -> continue_instr
Rule 26    instruction -> compound_instr
Rule 27    print_instr -> PRINT expression ;
Rule 28    print_instr -> PRINT error ;
Rule 29    labeled_instr -> ID : instruction
Rule 30    assignment -> ID = expression ;
Rule 31    choice_instr -> IF ( condition ) instruction
Rule 32    choice_instr -> IF ( condition ) instruction ELSE instruction
Rule 33    choice_instr -> IF ( error ) instruction
Rule 34    choice_instr -> IF ( error ) instruction ELSE instruction
Rule 35    while_instr -> WHILE ( condition ) instruction
Rule 36    while_instr -> WHILE ( error ) instruction
Rule 37    repeat_instr -> REPEAT instructions UNTIL condition ;
Rule 38    return_instr -> RETURN expression ;
Rule 39    continue_instr -> CONTINUE ;
Rule 40    break_instr -> BREAK ;
Rule 41    compound_instr -> { declarations instructions }
Rule 42    condition -> expression
Rule 43    const -> INTEGER
Rule 44    const -> FLOAT
Rule 45    const -> STRING
Rule 46    expression -> ID
Rule 47    expression -> const
Rule 48    expression -> expression + expression
Rule 49    expression -> expression - expression
Rule 50    expression -> expression * expression
Rule 51    expression -> expression / expression
Rule 52    expression -> expression % expression
Rule 53    expression -> expression | expression
Rule 54    expression -> expression & expression
Rule 55    expression -> expression ^ expression
Rule 56    expression -> expression AND expression
Rule 57    expression -> expression OR expression
Rule 58    expression -> expression SHL expression
Rule 59    expression -> expression SHR expression
Rule 60    expression -> expression EQ expression
Rule 61    expression -> expression NEQ expression
Rule 62    expression -> expression > expression
Rule 63    expression -> expression < expression
Rule 64    expression -> expression LE expression
Rule 65    expression -> expression GE expression
Rule 66    expression -> ( expression )
Rule 67    expression -> ( error )
Rule 68    expression -> ID ( expr_list_or_empty )
Rule 69    expression -> ID ( error )
Rule 70    expr_list_or_empty -> expr_list
Rule 71    expr_list_or_empty -> <empty>
Rule 72    expr_list -> expr_list , expression
Rule 73    expr_list -> expression
Rule 74    fundef -> TYPE ID ( args_list_or_empty ) compound_instr
Rule 75    args_list_or_empty -> args_list
Rule 76    args_list_or_empty -> <empty>
Rule 77    args_list -> args_list , arg
Rule 78    args_list -> arg
Rule 79    arg -> TYPE ID

Terminals, with rules where they appear

%                    : 52
&                    : 54
(                    : 31 32 33 34 35 36 66 67 68 69 74
)                    : 31 32 33 34 35 36 66 67 68 69 74
*                    : 50
+                    : 48
,                    : 12 72 77
-                    : 49
/                    : 51
:                    : 29
;                    : 10 11 27 28 30 37 38 39 40
<                    : 63
=                    : 14 30
>                    : 62
AND                  : 56
BREAK                : 40
CONTINUE             : 39
ELSE                 : 32 34
EQ                   : 60
FLOAT                : 44
GE                   : 65
ID                   : 14 29 30 46 68 69 74 79
IF                   : 31 32 33 34
INTEGER              : 43
LE                   : 64
NEQ                  : 61
OR                   : 57
PRINT                : 27 28
REPEAT               : 37
RETURN               : 38
SHL                  : 58
SHR                  : 59
STRING               : 45
TYPE                 : 10 74 79
UNTIL                : 37
WHILE                : 35 36
^                    : 55
error                : 11 28 33 34 36 67 69
{                    : 41
|                    : 53
}                    : 41

Nonterminals, with rules where they appear

arg                  : 77 78
args_list            : 75 77
args_list_or_empty   : 74
assignment           : 19
break_instr          : 24
choice_instr         : 20
compound_instr       : 26 74
condition            : 31 32 35 37
const                : 47
continue_instr       : 25
declaration          : 5 8
declarations         : 8 41
expr_list            : 70 72
expr_list_or_empty   : 68
expression           : 14 27 30 38 42 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 72 73
fundef               : 7
init                 : 12 13
inits                : 10 12
instruction          : 6 15 16 29 31 32 32 33 34 34 35 36
instructions         : 15 37 41
labeled_instr        : 18
print_instr          : 17
program              : 0
program_part         : 3 4
program_parts        : 1 3
repeat_instr         : 22
return_instr         : 23
while_instr          : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . program_parts
    (2) program -> .
    (3) program_parts -> . program_parts program_part
    (4) program_parts -> . program_part
    (5) program_part -> . declaration
    (6) program_part -> . instruction
    (7) program_part -> . fundef
    (10) declaration -> . TYPE inits ;
    (11) declaration -> . error ;
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (74) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    $end            reduce using rule 2 (program -> .)
    TYPE            shift and go to state 27
    error           shift and go to state 25
    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    program_part                   shift and go to state 19
    instruction                    shift and go to state 20
    choice_instr                   shift and go to state 3
    program_parts                  shift and go to state 4
    repeat_instr                   shift and go to state 7
    return_instr                   shift and go to state 8
    continue_instr                 shift and go to state 9
    while_instr                    shift and go to state 10
    program                        shift and go to state 11
    assignment                     shift and go to state 13
    labeled_instr                  shift and go to state 14
    declaration                    shift and go to state 16
    break_instr                    shift and go to state 2
    compound_instr                 shift and go to state 15
    fundef                         shift and go to state 21
    print_instr                    shift and go to state 23

state 1

    (38) return_instr -> RETURN . expression ;
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 34

state 2

    (24) instruction -> break_instr .

    }               reduce using rule 24 (instruction -> break_instr .)
    PRINT           reduce using rule 24 (instruction -> break_instr .)
    ID              reduce using rule 24 (instruction -> break_instr .)
    IF              reduce using rule 24 (instruction -> break_instr .)
    WHILE           reduce using rule 24 (instruction -> break_instr .)
    REPEAT          reduce using rule 24 (instruction -> break_instr .)
    RETURN          reduce using rule 24 (instruction -> break_instr .)
    BREAK           reduce using rule 24 (instruction -> break_instr .)
    CONTINUE        reduce using rule 24 (instruction -> break_instr .)
    {               reduce using rule 24 (instruction -> break_instr .)
    TYPE            reduce using rule 24 (instruction -> break_instr .)
    error           reduce using rule 24 (instruction -> break_instr .)
    $end            reduce using rule 24 (instruction -> break_instr .)
    UNTIL           reduce using rule 24 (instruction -> break_instr .)
    ELSE            reduce using rule 24 (instruction -> break_instr .)


state 3

    (20) instruction -> choice_instr .

    }               reduce using rule 20 (instruction -> choice_instr .)
    PRINT           reduce using rule 20 (instruction -> choice_instr .)
    ID              reduce using rule 20 (instruction -> choice_instr .)
    IF              reduce using rule 20 (instruction -> choice_instr .)
    WHILE           reduce using rule 20 (instruction -> choice_instr .)
    REPEAT          reduce using rule 20 (instruction -> choice_instr .)
    RETURN          reduce using rule 20 (instruction -> choice_instr .)
    BREAK           reduce using rule 20 (instruction -> choice_instr .)
    CONTINUE        reduce using rule 20 (instruction -> choice_instr .)
    {               reduce using rule 20 (instruction -> choice_instr .)
    TYPE            reduce using rule 20 (instruction -> choice_instr .)
    error           reduce using rule 20 (instruction -> choice_instr .)
    $end            reduce using rule 20 (instruction -> choice_instr .)
    UNTIL           reduce using rule 20 (instruction -> choice_instr .)
    ELSE            reduce using rule 20 (instruction -> choice_instr .)


state 4

    (1) program -> program_parts .
    (3) program_parts -> program_parts . program_part
    (5) program_part -> . declaration
    (6) program_part -> . instruction
    (7) program_part -> . fundef
    (10) declaration -> . TYPE inits ;
    (11) declaration -> . error ;
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (74) fundef -> . TYPE ID ( args_list_or_empty ) compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    $end            reduce using rule 1 (program -> program_parts .)
    TYPE            shift and go to state 27
    error           shift and go to state 25
    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    break_instr                    shift and go to state 2
    continue_instr                 shift and go to state 9
    assignment                     shift and go to state 13
    instruction                    shift and go to state 20
    compound_instr                 shift and go to state 15
    fundef                         shift and go to state 21
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    declaration                    shift and go to state 16
    while_instr                    shift and go to state 10
    program_part                   shift and go to state 35
    repeat_instr                   shift and go to state 7

state 5

    (27) print_instr -> PRINT . expression ;
    (28) print_instr -> PRINT . error ;
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    error           shift and go to state 36
    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 37

state 6

    (35) while_instr -> WHILE . ( condition ) instruction
    (36) while_instr -> WHILE . ( error ) instruction

    (               shift and go to state 38


state 7

    (22) instruction -> repeat_instr .

    }               reduce using rule 22 (instruction -> repeat_instr .)
    PRINT           reduce using rule 22 (instruction -> repeat_instr .)
    ID              reduce using rule 22 (instruction -> repeat_instr .)
    IF              reduce using rule 22 (instruction -> repeat_instr .)
    WHILE           reduce using rule 22 (instruction -> repeat_instr .)
    REPEAT          reduce using rule 22 (instruction -> repeat_instr .)
    RETURN          reduce using rule 22 (instruction -> repeat_instr .)
    BREAK           reduce using rule 22 (instruction -> repeat_instr .)
    CONTINUE        reduce using rule 22 (instruction -> repeat_instr .)
    {               reduce using rule 22 (instruction -> repeat_instr .)
    TYPE            reduce using rule 22 (instruction -> repeat_instr .)
    error           reduce using rule 22 (instruction -> repeat_instr .)
    $end            reduce using rule 22 (instruction -> repeat_instr .)
    UNTIL           reduce using rule 22 (instruction -> repeat_instr .)
    ELSE            reduce using rule 22 (instruction -> repeat_instr .)


state 8

    (23) instruction -> return_instr .

    }               reduce using rule 23 (instruction -> return_instr .)
    PRINT           reduce using rule 23 (instruction -> return_instr .)
    ID              reduce using rule 23 (instruction -> return_instr .)
    IF              reduce using rule 23 (instruction -> return_instr .)
    WHILE           reduce using rule 23 (instruction -> return_instr .)
    REPEAT          reduce using rule 23 (instruction -> return_instr .)
    RETURN          reduce using rule 23 (instruction -> return_instr .)
    BREAK           reduce using rule 23 (instruction -> return_instr .)
    CONTINUE        reduce using rule 23 (instruction -> return_instr .)
    {               reduce using rule 23 (instruction -> return_instr .)
    TYPE            reduce using rule 23 (instruction -> return_instr .)
    error           reduce using rule 23 (instruction -> return_instr .)
    $end            reduce using rule 23 (instruction -> return_instr .)
    UNTIL           reduce using rule 23 (instruction -> return_instr .)
    ELSE            reduce using rule 23 (instruction -> return_instr .)


state 9

    (25) instruction -> continue_instr .

    }               reduce using rule 25 (instruction -> continue_instr .)
    PRINT           reduce using rule 25 (instruction -> continue_instr .)
    ID              reduce using rule 25 (instruction -> continue_instr .)
    IF              reduce using rule 25 (instruction -> continue_instr .)
    WHILE           reduce using rule 25 (instruction -> continue_instr .)
    REPEAT          reduce using rule 25 (instruction -> continue_instr .)
    RETURN          reduce using rule 25 (instruction -> continue_instr .)
    BREAK           reduce using rule 25 (instruction -> continue_instr .)
    CONTINUE        reduce using rule 25 (instruction -> continue_instr .)
    {               reduce using rule 25 (instruction -> continue_instr .)
    TYPE            reduce using rule 25 (instruction -> continue_instr .)
    error           reduce using rule 25 (instruction -> continue_instr .)
    $end            reduce using rule 25 (instruction -> continue_instr .)
    UNTIL           reduce using rule 25 (instruction -> continue_instr .)
    ELSE            reduce using rule 25 (instruction -> continue_instr .)


state 10

    (21) instruction -> while_instr .

    }               reduce using rule 21 (instruction -> while_instr .)
    PRINT           reduce using rule 21 (instruction -> while_instr .)
    ID              reduce using rule 21 (instruction -> while_instr .)
    IF              reduce using rule 21 (instruction -> while_instr .)
    WHILE           reduce using rule 21 (instruction -> while_instr .)
    REPEAT          reduce using rule 21 (instruction -> while_instr .)
    RETURN          reduce using rule 21 (instruction -> while_instr .)
    BREAK           reduce using rule 21 (instruction -> while_instr .)
    CONTINUE        reduce using rule 21 (instruction -> while_instr .)
    {               reduce using rule 21 (instruction -> while_instr .)
    TYPE            reduce using rule 21 (instruction -> while_instr .)
    error           reduce using rule 21 (instruction -> while_instr .)
    $end            reduce using rule 21 (instruction -> while_instr .)
    UNTIL           reduce using rule 21 (instruction -> while_instr .)
    ELSE            reduce using rule 21 (instruction -> while_instr .)


state 11

    (0) S' -> program .



state 12

    (37) repeat_instr -> REPEAT . instructions UNTIL condition ;
    (15) instructions -> . instructions instruction
    (16) instructions -> . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 40
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 7
    break_instr                    shift and go to state 2
    while_instr                    shift and go to state 10
    instructions                   shift and go to state 39

state 13

    (19) instruction -> assignment .

    }               reduce using rule 19 (instruction -> assignment .)
    PRINT           reduce using rule 19 (instruction -> assignment .)
    ID              reduce using rule 19 (instruction -> assignment .)
    IF              reduce using rule 19 (instruction -> assignment .)
    WHILE           reduce using rule 19 (instruction -> assignment .)
    REPEAT          reduce using rule 19 (instruction -> assignment .)
    RETURN          reduce using rule 19 (instruction -> assignment .)
    BREAK           reduce using rule 19 (instruction -> assignment .)
    CONTINUE        reduce using rule 19 (instruction -> assignment .)
    {               reduce using rule 19 (instruction -> assignment .)
    TYPE            reduce using rule 19 (instruction -> assignment .)
    error           reduce using rule 19 (instruction -> assignment .)
    $end            reduce using rule 19 (instruction -> assignment .)
    UNTIL           reduce using rule 19 (instruction -> assignment .)
    ELSE            reduce using rule 19 (instruction -> assignment .)


state 14

    (18) instruction -> labeled_instr .

    }               reduce using rule 18 (instruction -> labeled_instr .)
    PRINT           reduce using rule 18 (instruction -> labeled_instr .)
    ID              reduce using rule 18 (instruction -> labeled_instr .)
    IF              reduce using rule 18 (instruction -> labeled_instr .)
    WHILE           reduce using rule 18 (instruction -> labeled_instr .)
    REPEAT          reduce using rule 18 (instruction -> labeled_instr .)
    RETURN          reduce using rule 18 (instruction -> labeled_instr .)
    BREAK           reduce using rule 18 (instruction -> labeled_instr .)
    CONTINUE        reduce using rule 18 (instruction -> labeled_instr .)
    {               reduce using rule 18 (instruction -> labeled_instr .)
    TYPE            reduce using rule 18 (instruction -> labeled_instr .)
    error           reduce using rule 18 (instruction -> labeled_instr .)
    $end            reduce using rule 18 (instruction -> labeled_instr .)
    UNTIL           reduce using rule 18 (instruction -> labeled_instr .)
    ELSE            reduce using rule 18 (instruction -> labeled_instr .)


state 15

    (26) instruction -> compound_instr .

    }               reduce using rule 26 (instruction -> compound_instr .)
    PRINT           reduce using rule 26 (instruction -> compound_instr .)
    ID              reduce using rule 26 (instruction -> compound_instr .)
    IF              reduce using rule 26 (instruction -> compound_instr .)
    WHILE           reduce using rule 26 (instruction -> compound_instr .)
    REPEAT          reduce using rule 26 (instruction -> compound_instr .)
    RETURN          reduce using rule 26 (instruction -> compound_instr .)
    BREAK           reduce using rule 26 (instruction -> compound_instr .)
    CONTINUE        reduce using rule 26 (instruction -> compound_instr .)
    {               reduce using rule 26 (instruction -> compound_instr .)
    TYPE            reduce using rule 26 (instruction -> compound_instr .)
    error           reduce using rule 26 (instruction -> compound_instr .)
    $end            reduce using rule 26 (instruction -> compound_instr .)
    UNTIL           reduce using rule 26 (instruction -> compound_instr .)
    ELSE            reduce using rule 26 (instruction -> compound_instr .)


state 16

    (5) program_part -> declaration .

    TYPE            reduce using rule 5 (program_part -> declaration .)
    error           reduce using rule 5 (program_part -> declaration .)
    PRINT           reduce using rule 5 (program_part -> declaration .)
    ID              reduce using rule 5 (program_part -> declaration .)
    IF              reduce using rule 5 (program_part -> declaration .)
    WHILE           reduce using rule 5 (program_part -> declaration .)
    REPEAT          reduce using rule 5 (program_part -> declaration .)
    RETURN          reduce using rule 5 (program_part -> declaration .)
    BREAK           reduce using rule 5 (program_part -> declaration .)
    CONTINUE        reduce using rule 5 (program_part -> declaration .)
    {               reduce using rule 5 (program_part -> declaration .)
    $end            reduce using rule 5 (program_part -> declaration .)


state 17

    (29) labeled_instr -> ID . : instruction
    (30) assignment -> ID . = expression ;

    :               shift and go to state 41
    =               shift and go to state 42


state 18

    (31) choice_instr -> IF . ( condition ) instruction
    (32) choice_instr -> IF . ( condition ) instruction ELSE instruction
    (33) choice_instr -> IF . ( error ) instruction
    (34) choice_instr -> IF . ( error ) instruction ELSE instruction

    (               shift and go to state 43


state 19

    (4) program_parts -> program_part .

    TYPE            reduce using rule 4 (program_parts -> program_part .)
    error           reduce using rule 4 (program_parts -> program_part .)
    PRINT           reduce using rule 4 (program_parts -> program_part .)
    ID              reduce using rule 4 (program_parts -> program_part .)
    IF              reduce using rule 4 (program_parts -> program_part .)
    WHILE           reduce using rule 4 (program_parts -> program_part .)
    REPEAT          reduce using rule 4 (program_parts -> program_part .)
    RETURN          reduce using rule 4 (program_parts -> program_part .)
    BREAK           reduce using rule 4 (program_parts -> program_part .)
    CONTINUE        reduce using rule 4 (program_parts -> program_part .)
    {               reduce using rule 4 (program_parts -> program_part .)
    $end            reduce using rule 4 (program_parts -> program_part .)


state 20

    (6) program_part -> instruction .

    TYPE            reduce using rule 6 (program_part -> instruction .)
    error           reduce using rule 6 (program_part -> instruction .)
    PRINT           reduce using rule 6 (program_part -> instruction .)
    ID              reduce using rule 6 (program_part -> instruction .)
    IF              reduce using rule 6 (program_part -> instruction .)
    WHILE           reduce using rule 6 (program_part -> instruction .)
    REPEAT          reduce using rule 6 (program_part -> instruction .)
    RETURN          reduce using rule 6 (program_part -> instruction .)
    BREAK           reduce using rule 6 (program_part -> instruction .)
    CONTINUE        reduce using rule 6 (program_part -> instruction .)
    {               reduce using rule 6 (program_part -> instruction .)
    $end            reduce using rule 6 (program_part -> instruction .)


state 21

    (7) program_part -> fundef .

    TYPE            reduce using rule 7 (program_part -> fundef .)
    error           reduce using rule 7 (program_part -> fundef .)
    PRINT           reduce using rule 7 (program_part -> fundef .)
    ID              reduce using rule 7 (program_part -> fundef .)
    IF              reduce using rule 7 (program_part -> fundef .)
    WHILE           reduce using rule 7 (program_part -> fundef .)
    REPEAT          reduce using rule 7 (program_part -> fundef .)
    RETURN          reduce using rule 7 (program_part -> fundef .)
    BREAK           reduce using rule 7 (program_part -> fundef .)
    CONTINUE        reduce using rule 7 (program_part -> fundef .)
    {               reduce using rule 7 (program_part -> fundef .)
    $end            reduce using rule 7 (program_part -> fundef .)


state 22

    (40) break_instr -> BREAK . ;

    ;               shift and go to state 44


state 23

    (17) instruction -> print_instr .

    }               reduce using rule 17 (instruction -> print_instr .)
    PRINT           reduce using rule 17 (instruction -> print_instr .)
    ID              reduce using rule 17 (instruction -> print_instr .)
    IF              reduce using rule 17 (instruction -> print_instr .)
    WHILE           reduce using rule 17 (instruction -> print_instr .)
    REPEAT          reduce using rule 17 (instruction -> print_instr .)
    RETURN          reduce using rule 17 (instruction -> print_instr .)
    BREAK           reduce using rule 17 (instruction -> print_instr .)
    CONTINUE        reduce using rule 17 (instruction -> print_instr .)
    {               reduce using rule 17 (instruction -> print_instr .)
    TYPE            reduce using rule 17 (instruction -> print_instr .)
    error           reduce using rule 17 (instruction -> print_instr .)
    $end            reduce using rule 17 (instruction -> print_instr .)
    UNTIL           reduce using rule 17 (instruction -> print_instr .)
    ELSE            reduce using rule 17 (instruction -> print_instr .)


state 24

    (39) continue_instr -> CONTINUE . ;

    ;               shift and go to state 45


state 25

    (11) declaration -> error . ;

    ;               shift and go to state 46


state 26

    (41) compound_instr -> { . declarations instructions }
    (8) declarations -> . declarations declaration
    (9) declarations -> .

    TYPE            reduce using rule 9 (declarations -> .)
    error           reduce using rule 9 (declarations -> .)
    PRINT           reduce using rule 9 (declarations -> .)
    ID              reduce using rule 9 (declarations -> .)
    IF              reduce using rule 9 (declarations -> .)
    WHILE           reduce using rule 9 (declarations -> .)
    REPEAT          reduce using rule 9 (declarations -> .)
    RETURN          reduce using rule 9 (declarations -> .)
    BREAK           reduce using rule 9 (declarations -> .)
    CONTINUE        reduce using rule 9 (declarations -> .)
    {               reduce using rule 9 (declarations -> .)

    declarations                   shift and go to state 47

state 27

    (10) declaration -> TYPE . inits ;
    (74) fundef -> TYPE . ID ( args_list_or_empty ) compound_instr
    (12) inits -> . inits , init
    (13) inits -> . init
    (14) init -> . ID = expression

    ID              shift and go to state 50

    init                           shift and go to state 48
    inits                          shift and go to state 49

state 28

    (47) expression -> const .

    +               reduce using rule 47 (expression -> const .)
    -               reduce using rule 47 (expression -> const .)
    *               reduce using rule 47 (expression -> const .)
    /               reduce using rule 47 (expression -> const .)
    %               reduce using rule 47 (expression -> const .)
    |               reduce using rule 47 (expression -> const .)
    &               reduce using rule 47 (expression -> const .)
    ^               reduce using rule 47 (expression -> const .)
    AND             reduce using rule 47 (expression -> const .)
    OR              reduce using rule 47 (expression -> const .)
    SHL             reduce using rule 47 (expression -> const .)
    SHR             reduce using rule 47 (expression -> const .)
    EQ              reduce using rule 47 (expression -> const .)
    NEQ             reduce using rule 47 (expression -> const .)
    >               reduce using rule 47 (expression -> const .)
    <               reduce using rule 47 (expression -> const .)
    LE              reduce using rule 47 (expression -> const .)
    GE              reduce using rule 47 (expression -> const .)
    ;               reduce using rule 47 (expression -> const .)
    )               reduce using rule 47 (expression -> const .)
    ,               reduce using rule 47 (expression -> const .)


state 29

    (43) const -> INTEGER .

    )               reduce using rule 43 (const -> INTEGER .)
    +               reduce using rule 43 (const -> INTEGER .)
    -               reduce using rule 43 (const -> INTEGER .)
    *               reduce using rule 43 (const -> INTEGER .)
    /               reduce using rule 43 (const -> INTEGER .)
    %               reduce using rule 43 (const -> INTEGER .)
    |               reduce using rule 43 (const -> INTEGER .)
    &               reduce using rule 43 (const -> INTEGER .)
    ^               reduce using rule 43 (const -> INTEGER .)
    AND             reduce using rule 43 (const -> INTEGER .)
    OR              reduce using rule 43 (const -> INTEGER .)
    SHL             reduce using rule 43 (const -> INTEGER .)
    SHR             reduce using rule 43 (const -> INTEGER .)
    EQ              reduce using rule 43 (const -> INTEGER .)
    NEQ             reduce using rule 43 (const -> INTEGER .)
    >               reduce using rule 43 (const -> INTEGER .)
    <               reduce using rule 43 (const -> INTEGER .)
    LE              reduce using rule 43 (const -> INTEGER .)
    GE              reduce using rule 43 (const -> INTEGER .)
    ;               reduce using rule 43 (const -> INTEGER .)
    ,               reduce using rule 43 (const -> INTEGER .)


state 30

    (45) const -> STRING .

    )               reduce using rule 45 (const -> STRING .)
    +               reduce using rule 45 (const -> STRING .)
    -               reduce using rule 45 (const -> STRING .)
    *               reduce using rule 45 (const -> STRING .)
    /               reduce using rule 45 (const -> STRING .)
    %               reduce using rule 45 (const -> STRING .)
    |               reduce using rule 45 (const -> STRING .)
    &               reduce using rule 45 (const -> STRING .)
    ^               reduce using rule 45 (const -> STRING .)
    AND             reduce using rule 45 (const -> STRING .)
    OR              reduce using rule 45 (const -> STRING .)
    SHL             reduce using rule 45 (const -> STRING .)
    SHR             reduce using rule 45 (const -> STRING .)
    EQ              reduce using rule 45 (const -> STRING .)
    NEQ             reduce using rule 45 (const -> STRING .)
    >               reduce using rule 45 (const -> STRING .)
    <               reduce using rule 45 (const -> STRING .)
    LE              reduce using rule 45 (const -> STRING .)
    GE              reduce using rule 45 (const -> STRING .)
    ;               reduce using rule 45 (const -> STRING .)
    ,               reduce using rule 45 (const -> STRING .)


state 31

    (46) expression -> ID .
    (68) expression -> ID . ( expr_list_or_empty )
    (69) expression -> ID . ( error )

    +               reduce using rule 46 (expression -> ID .)
    -               reduce using rule 46 (expression -> ID .)
    *               reduce using rule 46 (expression -> ID .)
    /               reduce using rule 46 (expression -> ID .)
    %               reduce using rule 46 (expression -> ID .)
    |               reduce using rule 46 (expression -> ID .)
    &               reduce using rule 46 (expression -> ID .)
    ^               reduce using rule 46 (expression -> ID .)
    AND             reduce using rule 46 (expression -> ID .)
    OR              reduce using rule 46 (expression -> ID .)
    SHL             reduce using rule 46 (expression -> ID .)
    SHR             reduce using rule 46 (expression -> ID .)
    EQ              reduce using rule 46 (expression -> ID .)
    NEQ             reduce using rule 46 (expression -> ID .)
    >               reduce using rule 46 (expression -> ID .)
    <               reduce using rule 46 (expression -> ID .)
    LE              reduce using rule 46 (expression -> ID .)
    GE              reduce using rule 46 (expression -> ID .)
    ;               reduce using rule 46 (expression -> ID .)
    )               reduce using rule 46 (expression -> ID .)
    ,               reduce using rule 46 (expression -> ID .)
    (               shift and go to state 51


state 32

    (44) const -> FLOAT .

    )               reduce using rule 44 (const -> FLOAT .)
    +               reduce using rule 44 (const -> FLOAT .)
    -               reduce using rule 44 (const -> FLOAT .)
    *               reduce using rule 44 (const -> FLOAT .)
    /               reduce using rule 44 (const -> FLOAT .)
    %               reduce using rule 44 (const -> FLOAT .)
    |               reduce using rule 44 (const -> FLOAT .)
    &               reduce using rule 44 (const -> FLOAT .)
    ^               reduce using rule 44 (const -> FLOAT .)
    AND             reduce using rule 44 (const -> FLOAT .)
    OR              reduce using rule 44 (const -> FLOAT .)
    SHL             reduce using rule 44 (const -> FLOAT .)
    SHR             reduce using rule 44 (const -> FLOAT .)
    EQ              reduce using rule 44 (const -> FLOAT .)
    NEQ             reduce using rule 44 (const -> FLOAT .)
    >               reduce using rule 44 (const -> FLOAT .)
    <               reduce using rule 44 (const -> FLOAT .)
    LE              reduce using rule 44 (const -> FLOAT .)
    GE              reduce using rule 44 (const -> FLOAT .)
    ;               reduce using rule 44 (const -> FLOAT .)
    ,               reduce using rule 44 (const -> FLOAT .)


state 33

    (66) expression -> ( . expression )
    (67) expression -> ( . error )
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    error           shift and go to state 52
    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 53

state 34

    (38) return_instr -> RETURN expression . ;
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    ;               shift and go to state 69
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 35

    (3) program_parts -> program_parts program_part .

    TYPE            reduce using rule 3 (program_parts -> program_parts program_part .)
    error           reduce using rule 3 (program_parts -> program_parts program_part .)
    PRINT           reduce using rule 3 (program_parts -> program_parts program_part .)
    ID              reduce using rule 3 (program_parts -> program_parts program_part .)
    IF              reduce using rule 3 (program_parts -> program_parts program_part .)
    WHILE           reduce using rule 3 (program_parts -> program_parts program_part .)
    REPEAT          reduce using rule 3 (program_parts -> program_parts program_part .)
    RETURN          reduce using rule 3 (program_parts -> program_parts program_part .)
    BREAK           reduce using rule 3 (program_parts -> program_parts program_part .)
    CONTINUE        reduce using rule 3 (program_parts -> program_parts program_part .)
    {               reduce using rule 3 (program_parts -> program_parts program_part .)
    $end            reduce using rule 3 (program_parts -> program_parts program_part .)


state 36

    (28) print_instr -> PRINT error . ;

    ;               shift and go to state 73


state 37

    (27) print_instr -> PRINT expression . ;
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    ;               shift and go to state 74
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 38

    (35) while_instr -> WHILE ( . condition ) instruction
    (36) while_instr -> WHILE ( . error ) instruction
    (42) condition -> . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    error           shift and go to state 76
    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 77
    condition                      shift and go to state 75

state 39

    (37) repeat_instr -> REPEAT instructions . UNTIL condition ;
    (15) instructions -> instructions . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    UNTIL           shift and go to state 78
    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 79
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 7
    break_instr                    shift and go to state 2
    while_instr                    shift and go to state 10

state 40

    (16) instructions -> instruction .

    }               reduce using rule 16 (instructions -> instruction .)
    PRINT           reduce using rule 16 (instructions -> instruction .)
    ID              reduce using rule 16 (instructions -> instruction .)
    IF              reduce using rule 16 (instructions -> instruction .)
    WHILE           reduce using rule 16 (instructions -> instruction .)
    REPEAT          reduce using rule 16 (instructions -> instruction .)
    RETURN          reduce using rule 16 (instructions -> instruction .)
    BREAK           reduce using rule 16 (instructions -> instruction .)
    CONTINUE        reduce using rule 16 (instructions -> instruction .)
    {               reduce using rule 16 (instructions -> instruction .)
    UNTIL           reduce using rule 16 (instructions -> instruction .)


state 41

    (29) labeled_instr -> ID : . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 80
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    while_instr                    shift and go to state 10
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 2
    labeled_instr                  shift and go to state 14
    repeat_instr                   shift and go to state 7

state 42

    (30) assignment -> ID = . expression ;
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 81

state 43

    (31) choice_instr -> IF ( . condition ) instruction
    (32) choice_instr -> IF ( . condition ) instruction ELSE instruction
    (33) choice_instr -> IF ( . error ) instruction
    (34) choice_instr -> IF ( . error ) instruction ELSE instruction
    (42) condition -> . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    error           shift and go to state 83
    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 77
    condition                      shift and go to state 82

state 44

    (40) break_instr -> BREAK ; .

    }               reduce using rule 40 (break_instr -> BREAK ; .)
    PRINT           reduce using rule 40 (break_instr -> BREAK ; .)
    ID              reduce using rule 40 (break_instr -> BREAK ; .)
    IF              reduce using rule 40 (break_instr -> BREAK ; .)
    WHILE           reduce using rule 40 (break_instr -> BREAK ; .)
    REPEAT          reduce using rule 40 (break_instr -> BREAK ; .)
    RETURN          reduce using rule 40 (break_instr -> BREAK ; .)
    BREAK           reduce using rule 40 (break_instr -> BREAK ; .)
    CONTINUE        reduce using rule 40 (break_instr -> BREAK ; .)
    {               reduce using rule 40 (break_instr -> BREAK ; .)
    TYPE            reduce using rule 40 (break_instr -> BREAK ; .)
    error           reduce using rule 40 (break_instr -> BREAK ; .)
    $end            reduce using rule 40 (break_instr -> BREAK ; .)
    UNTIL           reduce using rule 40 (break_instr -> BREAK ; .)
    ELSE            reduce using rule 40 (break_instr -> BREAK ; .)


state 45

    (39) continue_instr -> CONTINUE ; .

    TYPE            reduce using rule 39 (continue_instr -> CONTINUE ; .)
    error           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    PRINT           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    ID              reduce using rule 39 (continue_instr -> CONTINUE ; .)
    IF              reduce using rule 39 (continue_instr -> CONTINUE ; .)
    WHILE           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    REPEAT          reduce using rule 39 (continue_instr -> CONTINUE ; .)
    RETURN          reduce using rule 39 (continue_instr -> CONTINUE ; .)
    BREAK           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    CONTINUE        reduce using rule 39 (continue_instr -> CONTINUE ; .)
    {               reduce using rule 39 (continue_instr -> CONTINUE ; .)
    $end            reduce using rule 39 (continue_instr -> CONTINUE ; .)
    UNTIL           reduce using rule 39 (continue_instr -> CONTINUE ; .)
    }               reduce using rule 39 (continue_instr -> CONTINUE ; .)
    ELSE            reduce using rule 39 (continue_instr -> CONTINUE ; .)


state 46

    (11) declaration -> error ; .

    TYPE            reduce using rule 11 (declaration -> error ; .)
    error           reduce using rule 11 (declaration -> error ; .)
    PRINT           reduce using rule 11 (declaration -> error ; .)
    ID              reduce using rule 11 (declaration -> error ; .)
    IF              reduce using rule 11 (declaration -> error ; .)
    WHILE           reduce using rule 11 (declaration -> error ; .)
    REPEAT          reduce using rule 11 (declaration -> error ; .)
    RETURN          reduce using rule 11 (declaration -> error ; .)
    BREAK           reduce using rule 11 (declaration -> error ; .)
    CONTINUE        reduce using rule 11 (declaration -> error ; .)
    {               reduce using rule 11 (declaration -> error ; .)
    $end            reduce using rule 11 (declaration -> error ; .)


state 47

    (41) compound_instr -> { declarations . instructions }
    (8) declarations -> declarations . declaration
    (15) instructions -> . instructions instruction
    (16) instructions -> . instruction
    (10) declaration -> . TYPE inits ;
    (11) declaration -> . error ;
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    TYPE            shift and go to state 86
    error           shift and go to state 25
    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    break_instr                    shift and go to state 2
    instruction                    shift and go to state 40
    assignment                     shift and go to state 13
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    declaration                    shift and go to state 84
    while_instr                    shift and go to state 10
    repeat_instr                   shift and go to state 7
    instructions                   shift and go to state 85

state 48

    (13) inits -> init .

    ;               reduce using rule 13 (inits -> init .)
    ,               reduce using rule 13 (inits -> init .)


state 49

    (10) declaration -> TYPE inits . ;
    (12) inits -> inits . , init

    ;               shift and go to state 87
    ,               shift and go to state 88


state 50

    (74) fundef -> TYPE ID . ( args_list_or_empty ) compound_instr
    (14) init -> ID . = expression

    (               shift and go to state 89
    =               shift and go to state 90


state 51

    (68) expression -> ID ( . expr_list_or_empty )
    (69) expression -> ID ( . error )
    (70) expr_list_or_empty -> . expr_list
    (71) expr_list_or_empty -> .
    (72) expr_list -> . expr_list , expression
    (73) expr_list -> . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    error           shift and go to state 93
    )               reduce using rule 71 (expr_list_or_empty -> .)
    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    expr_list                      shift and go to state 91
    expr_list_or_empty             shift and go to state 92
    expression                     shift and go to state 94
    const                          shift and go to state 28

state 52

    (67) expression -> ( error . )

    )               shift and go to state 95


state 53

    (66) expression -> ( expression . )
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    )               shift and go to state 96
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 54

    (56) expression -> expression AND . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 97

state 55

    (59) expression -> expression SHR . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 98

state 56

    (64) expression -> expression LE . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 99

state 57

    (54) expression -> expression & . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 100

state 58

    (63) expression -> expression < . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 101

state 59

    (58) expression -> expression SHL . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 102

state 60

    (48) expression -> expression + . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 103

state 61

    (50) expression -> expression * . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 104

state 62

    (49) expression -> expression - . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 105

state 63

    (51) expression -> expression / . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 106

state 64

    (57) expression -> expression OR . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 107

state 65

    (60) expression -> expression EQ . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 108

state 66

    (62) expression -> expression > . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 109

state 67

    (65) expression -> expression GE . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 110

state 68

    (52) expression -> expression % . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 111

state 69

    (38) return_instr -> RETURN expression ; .

    TYPE            reduce using rule 38 (return_instr -> RETURN expression ; .)
    error           reduce using rule 38 (return_instr -> RETURN expression ; .)
    PRINT           reduce using rule 38 (return_instr -> RETURN expression ; .)
    ID              reduce using rule 38 (return_instr -> RETURN expression ; .)
    IF              reduce using rule 38 (return_instr -> RETURN expression ; .)
    WHILE           reduce using rule 38 (return_instr -> RETURN expression ; .)
    REPEAT          reduce using rule 38 (return_instr -> RETURN expression ; .)
    RETURN          reduce using rule 38 (return_instr -> RETURN expression ; .)
    BREAK           reduce using rule 38 (return_instr -> RETURN expression ; .)
    CONTINUE        reduce using rule 38 (return_instr -> RETURN expression ; .)
    {               reduce using rule 38 (return_instr -> RETURN expression ; .)
    $end            reduce using rule 38 (return_instr -> RETURN expression ; .)
    UNTIL           reduce using rule 38 (return_instr -> RETURN expression ; .)
    }               reduce using rule 38 (return_instr -> RETURN expression ; .)
    ELSE            reduce using rule 38 (return_instr -> RETURN expression ; .)


state 70

    (61) expression -> expression NEQ . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 112

state 71

    (53) expression -> expression | . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 113

state 72

    (55) expression -> expression ^ . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 114

state 73

    (28) print_instr -> PRINT error ; .

    UNTIL           reduce using rule 28 (print_instr -> PRINT error ; .)
    PRINT           reduce using rule 28 (print_instr -> PRINT error ; .)
    ID              reduce using rule 28 (print_instr -> PRINT error ; .)
    IF              reduce using rule 28 (print_instr -> PRINT error ; .)
    WHILE           reduce using rule 28 (print_instr -> PRINT error ; .)
    REPEAT          reduce using rule 28 (print_instr -> PRINT error ; .)
    RETURN          reduce using rule 28 (print_instr -> PRINT error ; .)
    BREAK           reduce using rule 28 (print_instr -> PRINT error ; .)
    CONTINUE        reduce using rule 28 (print_instr -> PRINT error ; .)
    {               reduce using rule 28 (print_instr -> PRINT error ; .)
    }               reduce using rule 28 (print_instr -> PRINT error ; .)
    TYPE            reduce using rule 28 (print_instr -> PRINT error ; .)
    error           reduce using rule 28 (print_instr -> PRINT error ; .)
    $end            reduce using rule 28 (print_instr -> PRINT error ; .)
    ELSE            reduce using rule 28 (print_instr -> PRINT error ; .)


state 74

    (27) print_instr -> PRINT expression ; .

    UNTIL           reduce using rule 27 (print_instr -> PRINT expression ; .)
    PRINT           reduce using rule 27 (print_instr -> PRINT expression ; .)
    ID              reduce using rule 27 (print_instr -> PRINT expression ; .)
    IF              reduce using rule 27 (print_instr -> PRINT expression ; .)
    WHILE           reduce using rule 27 (print_instr -> PRINT expression ; .)
    REPEAT          reduce using rule 27 (print_instr -> PRINT expression ; .)
    RETURN          reduce using rule 27 (print_instr -> PRINT expression ; .)
    BREAK           reduce using rule 27 (print_instr -> PRINT expression ; .)
    CONTINUE        reduce using rule 27 (print_instr -> PRINT expression ; .)
    {               reduce using rule 27 (print_instr -> PRINT expression ; .)
    }               reduce using rule 27 (print_instr -> PRINT expression ; .)
    TYPE            reduce using rule 27 (print_instr -> PRINT expression ; .)
    error           reduce using rule 27 (print_instr -> PRINT expression ; .)
    $end            reduce using rule 27 (print_instr -> PRINT expression ; .)
    ELSE            reduce using rule 27 (print_instr -> PRINT expression ; .)


state 75

    (35) while_instr -> WHILE ( condition . ) instruction

    )               shift and go to state 115


state 76

    (36) while_instr -> WHILE ( error . ) instruction

    )               shift and go to state 116


state 77

    (42) condition -> expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    ;               reduce using rule 42 (condition -> expression .)
    )               reduce using rule 42 (condition -> expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 78

    (37) repeat_instr -> REPEAT instructions UNTIL . condition ;
    (42) condition -> . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 77
    condition                      shift and go to state 117

state 79

    (15) instructions -> instructions instruction .

    }               reduce using rule 15 (instructions -> instructions instruction .)
    PRINT           reduce using rule 15 (instructions -> instructions instruction .)
    ID              reduce using rule 15 (instructions -> instructions instruction .)
    IF              reduce using rule 15 (instructions -> instructions instruction .)
    WHILE           reduce using rule 15 (instructions -> instructions instruction .)
    REPEAT          reduce using rule 15 (instructions -> instructions instruction .)
    RETURN          reduce using rule 15 (instructions -> instructions instruction .)
    BREAK           reduce using rule 15 (instructions -> instructions instruction .)
    CONTINUE        reduce using rule 15 (instructions -> instructions instruction .)
    {               reduce using rule 15 (instructions -> instructions instruction .)
    UNTIL           reduce using rule 15 (instructions -> instructions instruction .)


state 80

    (29) labeled_instr -> ID : instruction .

    TYPE            reduce using rule 29 (labeled_instr -> ID : instruction .)
    error           reduce using rule 29 (labeled_instr -> ID : instruction .)
    PRINT           reduce using rule 29 (labeled_instr -> ID : instruction .)
    ID              reduce using rule 29 (labeled_instr -> ID : instruction .)
    IF              reduce using rule 29 (labeled_instr -> ID : instruction .)
    WHILE           reduce using rule 29 (labeled_instr -> ID : instruction .)
    REPEAT          reduce using rule 29 (labeled_instr -> ID : instruction .)
    RETURN          reduce using rule 29 (labeled_instr -> ID : instruction .)
    BREAK           reduce using rule 29 (labeled_instr -> ID : instruction .)
    CONTINUE        reduce using rule 29 (labeled_instr -> ID : instruction .)
    {               reduce using rule 29 (labeled_instr -> ID : instruction .)
    $end            reduce using rule 29 (labeled_instr -> ID : instruction .)
    UNTIL           reduce using rule 29 (labeled_instr -> ID : instruction .)
    }               reduce using rule 29 (labeled_instr -> ID : instruction .)
    ELSE            reduce using rule 29 (labeled_instr -> ID : instruction .)


state 81

    (30) assignment -> ID = expression . ;
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    ;               shift and go to state 118
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 82

    (31) choice_instr -> IF ( condition . ) instruction
    (32) choice_instr -> IF ( condition . ) instruction ELSE instruction

    )               shift and go to state 119


state 83

    (33) choice_instr -> IF ( error . ) instruction
    (34) choice_instr -> IF ( error . ) instruction ELSE instruction

    )               shift and go to state 120


state 84

    (8) declarations -> declarations declaration .

    TYPE            reduce using rule 8 (declarations -> declarations declaration .)
    error           reduce using rule 8 (declarations -> declarations declaration .)
    PRINT           reduce using rule 8 (declarations -> declarations declaration .)
    ID              reduce using rule 8 (declarations -> declarations declaration .)
    IF              reduce using rule 8 (declarations -> declarations declaration .)
    WHILE           reduce using rule 8 (declarations -> declarations declaration .)
    REPEAT          reduce using rule 8 (declarations -> declarations declaration .)
    RETURN          reduce using rule 8 (declarations -> declarations declaration .)
    BREAK           reduce using rule 8 (declarations -> declarations declaration .)
    CONTINUE        reduce using rule 8 (declarations -> declarations declaration .)
    {               reduce using rule 8 (declarations -> declarations declaration .)


state 85

    (41) compound_instr -> { declarations instructions . }
    (15) instructions -> instructions . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    }               shift and go to state 121
    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    instruction                    shift and go to state 79
    assignment                     shift and go to state 13
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 2
    while_instr                    shift and go to state 10
    repeat_instr                   shift and go to state 7

state 86

    (10) declaration -> TYPE . inits ;
    (12) inits -> . inits , init
    (13) inits -> . init
    (14) init -> . ID = expression

    ID              shift and go to state 122

    init                           shift and go to state 48
    inits                          shift and go to state 49

state 87

    (10) declaration -> TYPE inits ; .

    TYPE            reduce using rule 10 (declaration -> TYPE inits ; .)
    error           reduce using rule 10 (declaration -> TYPE inits ; .)
    PRINT           reduce using rule 10 (declaration -> TYPE inits ; .)
    ID              reduce using rule 10 (declaration -> TYPE inits ; .)
    IF              reduce using rule 10 (declaration -> TYPE inits ; .)
    WHILE           reduce using rule 10 (declaration -> TYPE inits ; .)
    REPEAT          reduce using rule 10 (declaration -> TYPE inits ; .)
    RETURN          reduce using rule 10 (declaration -> TYPE inits ; .)
    BREAK           reduce using rule 10 (declaration -> TYPE inits ; .)
    CONTINUE        reduce using rule 10 (declaration -> TYPE inits ; .)
    {               reduce using rule 10 (declaration -> TYPE inits ; .)
    $end            reduce using rule 10 (declaration -> TYPE inits ; .)


state 88

    (12) inits -> inits , . init
    (14) init -> . ID = expression

    ID              shift and go to state 122

    init                           shift and go to state 123

state 89

    (74) fundef -> TYPE ID ( . args_list_or_empty ) compound_instr
    (75) args_list_or_empty -> . args_list
    (76) args_list_or_empty -> .
    (77) args_list -> . args_list , arg
    (78) args_list -> . arg
    (79) arg -> . TYPE ID

    )               reduce using rule 76 (args_list_or_empty -> .)
    TYPE            shift and go to state 127

    args_list_or_empty             shift and go to state 125
    arg                            shift and go to state 126
    args_list                      shift and go to state 124

state 90

    (14) init -> ID = . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    const                          shift and go to state 28
    expression                     shift and go to state 128

state 91

    (70) expr_list_or_empty -> expr_list .
    (72) expr_list -> expr_list . , expression

    )               reduce using rule 70 (expr_list_or_empty -> expr_list .)
    ,               shift and go to state 129


state 92

    (68) expression -> ID ( expr_list_or_empty . )

    )               shift and go to state 130


state 93

    (69) expression -> ID ( error . )

    )               shift and go to state 131


state 94

    (73) expr_list -> expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    ,               reduce using rule 73 (expr_list -> expression .)
    )               reduce using rule 73 (expr_list -> expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 95

    (67) expression -> ( error ) .

    +               reduce using rule 67 (expression -> ( error ) .)
    -               reduce using rule 67 (expression -> ( error ) .)
    *               reduce using rule 67 (expression -> ( error ) .)
    /               reduce using rule 67 (expression -> ( error ) .)
    %               reduce using rule 67 (expression -> ( error ) .)
    |               reduce using rule 67 (expression -> ( error ) .)
    &               reduce using rule 67 (expression -> ( error ) .)
    ^               reduce using rule 67 (expression -> ( error ) .)
    AND             reduce using rule 67 (expression -> ( error ) .)
    OR              reduce using rule 67 (expression -> ( error ) .)
    SHL             reduce using rule 67 (expression -> ( error ) .)
    SHR             reduce using rule 67 (expression -> ( error ) .)
    EQ              reduce using rule 67 (expression -> ( error ) .)
    NEQ             reduce using rule 67 (expression -> ( error ) .)
    >               reduce using rule 67 (expression -> ( error ) .)
    <               reduce using rule 67 (expression -> ( error ) .)
    LE              reduce using rule 67 (expression -> ( error ) .)
    GE              reduce using rule 67 (expression -> ( error ) .)
    ;               reduce using rule 67 (expression -> ( error ) .)
    )               reduce using rule 67 (expression -> ( error ) .)
    ,               reduce using rule 67 (expression -> ( error ) .)


state 96

    (66) expression -> ( expression ) .

    +               reduce using rule 66 (expression -> ( expression ) .)
    -               reduce using rule 66 (expression -> ( expression ) .)
    *               reduce using rule 66 (expression -> ( expression ) .)
    /               reduce using rule 66 (expression -> ( expression ) .)
    %               reduce using rule 66 (expression -> ( expression ) .)
    |               reduce using rule 66 (expression -> ( expression ) .)
    &               reduce using rule 66 (expression -> ( expression ) .)
    ^               reduce using rule 66 (expression -> ( expression ) .)
    AND             reduce using rule 66 (expression -> ( expression ) .)
    OR              reduce using rule 66 (expression -> ( expression ) .)
    SHL             reduce using rule 66 (expression -> ( expression ) .)
    SHR             reduce using rule 66 (expression -> ( expression ) .)
    EQ              reduce using rule 66 (expression -> ( expression ) .)
    NEQ             reduce using rule 66 (expression -> ( expression ) .)
    >               reduce using rule 66 (expression -> ( expression ) .)
    <               reduce using rule 66 (expression -> ( expression ) .)
    LE              reduce using rule 66 (expression -> ( expression ) .)
    GE              reduce using rule 66 (expression -> ( expression ) .)
    ;               reduce using rule 66 (expression -> ( expression ) .)
    )               reduce using rule 66 (expression -> ( expression ) .)
    ,               reduce using rule 66 (expression -> ( expression ) .)


state 97

    (56) expression -> expression AND expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    AND             reduce using rule 56 (expression -> expression AND expression .)
    OR              reduce using rule 56 (expression -> expression AND expression .)
    ;               reduce using rule 56 (expression -> expression AND expression .)
    )               reduce using rule 56 (expression -> expression AND expression .)
    ,               reduce using rule 56 (expression -> expression AND expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67

  ! +               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! -               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! *               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! /               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! %               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! |               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! &               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! ^               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! SHL             [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! SHR             [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! EQ              [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! NEQ             [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! >               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! <               [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! LE              [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! GE              [ reduce using rule 56 (expression -> expression AND expression .) ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]


state 98

    (59) expression -> expression SHR expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 59 (expression -> expression SHR expression .)
    &               reduce using rule 59 (expression -> expression SHR expression .)
    ^               reduce using rule 59 (expression -> expression SHR expression .)
    AND             reduce using rule 59 (expression -> expression SHR expression .)
    OR              reduce using rule 59 (expression -> expression SHR expression .)
    SHL             reduce using rule 59 (expression -> expression SHR expression .)
    SHR             reduce using rule 59 (expression -> expression SHR expression .)
    EQ              reduce using rule 59 (expression -> expression SHR expression .)
    NEQ             reduce using rule 59 (expression -> expression SHR expression .)
    >               reduce using rule 59 (expression -> expression SHR expression .)
    <               reduce using rule 59 (expression -> expression SHR expression .)
    LE              reduce using rule 59 (expression -> expression SHR expression .)
    GE              reduce using rule 59 (expression -> expression SHR expression .)
    ;               reduce using rule 59 (expression -> expression SHR expression .)
    )               reduce using rule 59 (expression -> expression SHR expression .)
    ,               reduce using rule 59 (expression -> expression SHR expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68

  ! +               [ reduce using rule 59 (expression -> expression SHR expression .) ]
  ! -               [ reduce using rule 59 (expression -> expression SHR expression .) ]
  ! *               [ reduce using rule 59 (expression -> expression SHR expression .) ]
  ! /               [ reduce using rule 59 (expression -> expression SHR expression .) ]
  ! %               [ reduce using rule 59 (expression -> expression SHR expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! SHL             [ shift and go to state 59 ]
  ! SHR             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 99

    (64) expression -> expression LE expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 64 (expression -> expression LE expression .)
    &               reduce using rule 64 (expression -> expression LE expression .)
    ^               reduce using rule 64 (expression -> expression LE expression .)
    AND             reduce using rule 64 (expression -> expression LE expression .)
    OR              reduce using rule 64 (expression -> expression LE expression .)
    EQ              reduce using rule 64 (expression -> expression LE expression .)
    NEQ             reduce using rule 64 (expression -> expression LE expression .)
    >               reduce using rule 64 (expression -> expression LE expression .)
    <               reduce using rule 64 (expression -> expression LE expression .)
    LE              reduce using rule 64 (expression -> expression LE expression .)
    GE              reduce using rule 64 (expression -> expression LE expression .)
    ;               reduce using rule 64 (expression -> expression LE expression .)
    )               reduce using rule 64 (expression -> expression LE expression .)
    ,               reduce using rule 64 (expression -> expression LE expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    SHL             shift and go to state 59
    SHR             shift and go to state 55

  ! +               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! -               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! *               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! /               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! %               [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! SHL             [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! SHR             [ reduce using rule 64 (expression -> expression LE expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 100

    (54) expression -> expression & expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 54 (expression -> expression & expression .)
    &               reduce using rule 54 (expression -> expression & expression .)
    ^               reduce using rule 54 (expression -> expression & expression .)
    AND             reduce using rule 54 (expression -> expression & expression .)
    OR              reduce using rule 54 (expression -> expression & expression .)
    ;               reduce using rule 54 (expression -> expression & expression .)
    )               reduce using rule 54 (expression -> expression & expression .)
    ,               reduce using rule 54 (expression -> expression & expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67

  ! +               [ reduce using rule 54 (expression -> expression & expression .) ]
  ! -               [ reduce using rule 54 (expression -> expression & expression .) ]
  ! *               [ reduce using rule 54 (expression -> expression & expression .) ]
  ! /               [ reduce using rule 54 (expression -> expression & expression .) ]
  ! %               [ reduce using rule 54 (expression -> expression & expression .) ]
  ! SHL             [ reduce using rule 54 (expression -> expression & expression .) ]
  ! SHR             [ reduce using rule 54 (expression -> expression & expression .) ]
  ! EQ              [ reduce using rule 54 (expression -> expression & expression .) ]
  ! NEQ             [ reduce using rule 54 (expression -> expression & expression .) ]
  ! >               [ reduce using rule 54 (expression -> expression & expression .) ]
  ! <               [ reduce using rule 54 (expression -> expression & expression .) ]
  ! LE              [ reduce using rule 54 (expression -> expression & expression .) ]
  ! GE              [ reduce using rule 54 (expression -> expression & expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]


state 101

    (63) expression -> expression < expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 63 (expression -> expression < expression .)
    &               reduce using rule 63 (expression -> expression < expression .)
    ^               reduce using rule 63 (expression -> expression < expression .)
    AND             reduce using rule 63 (expression -> expression < expression .)
    OR              reduce using rule 63 (expression -> expression < expression .)
    EQ              reduce using rule 63 (expression -> expression < expression .)
    NEQ             reduce using rule 63 (expression -> expression < expression .)
    >               reduce using rule 63 (expression -> expression < expression .)
    <               reduce using rule 63 (expression -> expression < expression .)
    LE              reduce using rule 63 (expression -> expression < expression .)
    GE              reduce using rule 63 (expression -> expression < expression .)
    ;               reduce using rule 63 (expression -> expression < expression .)
    )               reduce using rule 63 (expression -> expression < expression .)
    ,               reduce using rule 63 (expression -> expression < expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    SHL             shift and go to state 59
    SHR             shift and go to state 55

  ! +               [ reduce using rule 63 (expression -> expression < expression .) ]
  ! -               [ reduce using rule 63 (expression -> expression < expression .) ]
  ! *               [ reduce using rule 63 (expression -> expression < expression .) ]
  ! /               [ reduce using rule 63 (expression -> expression < expression .) ]
  ! %               [ reduce using rule 63 (expression -> expression < expression .) ]
  ! SHL             [ reduce using rule 63 (expression -> expression < expression .) ]
  ! SHR             [ reduce using rule 63 (expression -> expression < expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 102

    (58) expression -> expression SHL expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 58 (expression -> expression SHL expression .)
    &               reduce using rule 58 (expression -> expression SHL expression .)
    ^               reduce using rule 58 (expression -> expression SHL expression .)
    AND             reduce using rule 58 (expression -> expression SHL expression .)
    OR              reduce using rule 58 (expression -> expression SHL expression .)
    SHL             reduce using rule 58 (expression -> expression SHL expression .)
    SHR             reduce using rule 58 (expression -> expression SHL expression .)
    EQ              reduce using rule 58 (expression -> expression SHL expression .)
    NEQ             reduce using rule 58 (expression -> expression SHL expression .)
    >               reduce using rule 58 (expression -> expression SHL expression .)
    <               reduce using rule 58 (expression -> expression SHL expression .)
    LE              reduce using rule 58 (expression -> expression SHL expression .)
    GE              reduce using rule 58 (expression -> expression SHL expression .)
    ;               reduce using rule 58 (expression -> expression SHL expression .)
    )               reduce using rule 58 (expression -> expression SHL expression .)
    ,               reduce using rule 58 (expression -> expression SHL expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68

  ! +               [ reduce using rule 58 (expression -> expression SHL expression .) ]
  ! -               [ reduce using rule 58 (expression -> expression SHL expression .) ]
  ! *               [ reduce using rule 58 (expression -> expression SHL expression .) ]
  ! /               [ reduce using rule 58 (expression -> expression SHL expression .) ]
  ! %               [ reduce using rule 58 (expression -> expression SHL expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! SHL             [ shift and go to state 59 ]
  ! SHR             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 103

    (48) expression -> expression + expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    +               reduce using rule 48 (expression -> expression + expression .)
    -               reduce using rule 48 (expression -> expression + expression .)
    |               reduce using rule 48 (expression -> expression + expression .)
    &               reduce using rule 48 (expression -> expression + expression .)
    ^               reduce using rule 48 (expression -> expression + expression .)
    AND             reduce using rule 48 (expression -> expression + expression .)
    OR              reduce using rule 48 (expression -> expression + expression .)
    SHL             reduce using rule 48 (expression -> expression + expression .)
    SHR             reduce using rule 48 (expression -> expression + expression .)
    EQ              reduce using rule 48 (expression -> expression + expression .)
    NEQ             reduce using rule 48 (expression -> expression + expression .)
    >               reduce using rule 48 (expression -> expression + expression .)
    <               reduce using rule 48 (expression -> expression + expression .)
    LE              reduce using rule 48 (expression -> expression + expression .)
    GE              reduce using rule 48 (expression -> expression + expression .)
    ;               reduce using rule 48 (expression -> expression + expression .)
    )               reduce using rule 48 (expression -> expression + expression .)
    ,               reduce using rule 48 (expression -> expression + expression .)
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68

  ! *               [ reduce using rule 48 (expression -> expression + expression .) ]
  ! /               [ reduce using rule 48 (expression -> expression + expression .) ]
  ! %               [ reduce using rule 48 (expression -> expression + expression .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 62 ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! SHL             [ shift and go to state 59 ]
  ! SHR             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 104

    (50) expression -> expression * expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    +               reduce using rule 50 (expression -> expression * expression .)
    -               reduce using rule 50 (expression -> expression * expression .)
    *               reduce using rule 50 (expression -> expression * expression .)
    /               reduce using rule 50 (expression -> expression * expression .)
    %               reduce using rule 50 (expression -> expression * expression .)
    |               reduce using rule 50 (expression -> expression * expression .)
    &               reduce using rule 50 (expression -> expression * expression .)
    ^               reduce using rule 50 (expression -> expression * expression .)
    AND             reduce using rule 50 (expression -> expression * expression .)
    OR              reduce using rule 50 (expression -> expression * expression .)
    SHL             reduce using rule 50 (expression -> expression * expression .)
    SHR             reduce using rule 50 (expression -> expression * expression .)
    EQ              reduce using rule 50 (expression -> expression * expression .)
    NEQ             reduce using rule 50 (expression -> expression * expression .)
    >               reduce using rule 50 (expression -> expression * expression .)
    <               reduce using rule 50 (expression -> expression * expression .)
    LE              reduce using rule 50 (expression -> expression * expression .)
    GE              reduce using rule 50 (expression -> expression * expression .)
    ;               reduce using rule 50 (expression -> expression * expression .)
    )               reduce using rule 50 (expression -> expression * expression .)
    ,               reduce using rule 50 (expression -> expression * expression .)

  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 62 ]
  ! *               [ shift and go to state 61 ]
  ! /               [ shift and go to state 63 ]
  ! %               [ shift and go to state 68 ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! SHL             [ shift and go to state 59 ]
  ! SHR             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 105

    (49) expression -> expression - expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    +               reduce using rule 49 (expression -> expression - expression .)
    -               reduce using rule 49 (expression -> expression - expression .)
    |               reduce using rule 49 (expression -> expression - expression .)
    &               reduce using rule 49 (expression -> expression - expression .)
    ^               reduce using rule 49 (expression -> expression - expression .)
    AND             reduce using rule 49 (expression -> expression - expression .)
    OR              reduce using rule 49 (expression -> expression - expression .)
    SHL             reduce using rule 49 (expression -> expression - expression .)
    SHR             reduce using rule 49 (expression -> expression - expression .)
    EQ              reduce using rule 49 (expression -> expression - expression .)
    NEQ             reduce using rule 49 (expression -> expression - expression .)
    >               reduce using rule 49 (expression -> expression - expression .)
    <               reduce using rule 49 (expression -> expression - expression .)
    LE              reduce using rule 49 (expression -> expression - expression .)
    GE              reduce using rule 49 (expression -> expression - expression .)
    ;               reduce using rule 49 (expression -> expression - expression .)
    )               reduce using rule 49 (expression -> expression - expression .)
    ,               reduce using rule 49 (expression -> expression - expression .)
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68

  ! *               [ reduce using rule 49 (expression -> expression - expression .) ]
  ! /               [ reduce using rule 49 (expression -> expression - expression .) ]
  ! %               [ reduce using rule 49 (expression -> expression - expression .) ]
  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 62 ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! SHL             [ shift and go to state 59 ]
  ! SHR             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 106

    (51) expression -> expression / expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    +               reduce using rule 51 (expression -> expression / expression .)
    -               reduce using rule 51 (expression -> expression / expression .)
    *               reduce using rule 51 (expression -> expression / expression .)
    /               reduce using rule 51 (expression -> expression / expression .)
    %               reduce using rule 51 (expression -> expression / expression .)
    |               reduce using rule 51 (expression -> expression / expression .)
    &               reduce using rule 51 (expression -> expression / expression .)
    ^               reduce using rule 51 (expression -> expression / expression .)
    AND             reduce using rule 51 (expression -> expression / expression .)
    OR              reduce using rule 51 (expression -> expression / expression .)
    SHL             reduce using rule 51 (expression -> expression / expression .)
    SHR             reduce using rule 51 (expression -> expression / expression .)
    EQ              reduce using rule 51 (expression -> expression / expression .)
    NEQ             reduce using rule 51 (expression -> expression / expression .)
    >               reduce using rule 51 (expression -> expression / expression .)
    <               reduce using rule 51 (expression -> expression / expression .)
    LE              reduce using rule 51 (expression -> expression / expression .)
    GE              reduce using rule 51 (expression -> expression / expression .)
    ;               reduce using rule 51 (expression -> expression / expression .)
    )               reduce using rule 51 (expression -> expression / expression .)
    ,               reduce using rule 51 (expression -> expression / expression .)

  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 62 ]
  ! *               [ shift and go to state 61 ]
  ! /               [ shift and go to state 63 ]
  ! %               [ shift and go to state 68 ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! SHL             [ shift and go to state 59 ]
  ! SHR             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 107

    (57) expression -> expression OR expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    OR              reduce using rule 57 (expression -> expression OR expression .)
    ;               reduce using rule 57 (expression -> expression OR expression .)
    )               reduce using rule 57 (expression -> expression OR expression .)
    ,               reduce using rule 57 (expression -> expression OR expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67

  ! +               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! -               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! *               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! /               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! %               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! |               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! &               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! ^               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! AND             [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! SHL             [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! SHR             [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! EQ              [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! NEQ             [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! >               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! <               [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! LE              [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! GE              [ reduce using rule 57 (expression -> expression OR expression .) ]
  ! OR              [ shift and go to state 64 ]


state 108

    (60) expression -> expression EQ expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 60 (expression -> expression EQ expression .)
    &               reduce using rule 60 (expression -> expression EQ expression .)
    ^               reduce using rule 60 (expression -> expression EQ expression .)
    AND             reduce using rule 60 (expression -> expression EQ expression .)
    OR              reduce using rule 60 (expression -> expression EQ expression .)
    EQ              reduce using rule 60 (expression -> expression EQ expression .)
    NEQ             reduce using rule 60 (expression -> expression EQ expression .)
    >               reduce using rule 60 (expression -> expression EQ expression .)
    <               reduce using rule 60 (expression -> expression EQ expression .)
    LE              reduce using rule 60 (expression -> expression EQ expression .)
    GE              reduce using rule 60 (expression -> expression EQ expression .)
    ;               reduce using rule 60 (expression -> expression EQ expression .)
    )               reduce using rule 60 (expression -> expression EQ expression .)
    ,               reduce using rule 60 (expression -> expression EQ expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    SHL             shift and go to state 59
    SHR             shift and go to state 55

  ! +               [ reduce using rule 60 (expression -> expression EQ expression .) ]
  ! -               [ reduce using rule 60 (expression -> expression EQ expression .) ]
  ! *               [ reduce using rule 60 (expression -> expression EQ expression .) ]
  ! /               [ reduce using rule 60 (expression -> expression EQ expression .) ]
  ! %               [ reduce using rule 60 (expression -> expression EQ expression .) ]
  ! SHL             [ reduce using rule 60 (expression -> expression EQ expression .) ]
  ! SHR             [ reduce using rule 60 (expression -> expression EQ expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 109

    (62) expression -> expression > expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 62 (expression -> expression > expression .)
    &               reduce using rule 62 (expression -> expression > expression .)
    ^               reduce using rule 62 (expression -> expression > expression .)
    AND             reduce using rule 62 (expression -> expression > expression .)
    OR              reduce using rule 62 (expression -> expression > expression .)
    EQ              reduce using rule 62 (expression -> expression > expression .)
    NEQ             reduce using rule 62 (expression -> expression > expression .)
    >               reduce using rule 62 (expression -> expression > expression .)
    <               reduce using rule 62 (expression -> expression > expression .)
    LE              reduce using rule 62 (expression -> expression > expression .)
    GE              reduce using rule 62 (expression -> expression > expression .)
    ;               reduce using rule 62 (expression -> expression > expression .)
    )               reduce using rule 62 (expression -> expression > expression .)
    ,               reduce using rule 62 (expression -> expression > expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    SHL             shift and go to state 59
    SHR             shift and go to state 55

  ! +               [ reduce using rule 62 (expression -> expression > expression .) ]
  ! -               [ reduce using rule 62 (expression -> expression > expression .) ]
  ! *               [ reduce using rule 62 (expression -> expression > expression .) ]
  ! /               [ reduce using rule 62 (expression -> expression > expression .) ]
  ! %               [ reduce using rule 62 (expression -> expression > expression .) ]
  ! SHL             [ reduce using rule 62 (expression -> expression > expression .) ]
  ! SHR             [ reduce using rule 62 (expression -> expression > expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 110

    (65) expression -> expression GE expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 65 (expression -> expression GE expression .)
    &               reduce using rule 65 (expression -> expression GE expression .)
    ^               reduce using rule 65 (expression -> expression GE expression .)
    AND             reduce using rule 65 (expression -> expression GE expression .)
    OR              reduce using rule 65 (expression -> expression GE expression .)
    EQ              reduce using rule 65 (expression -> expression GE expression .)
    NEQ             reduce using rule 65 (expression -> expression GE expression .)
    >               reduce using rule 65 (expression -> expression GE expression .)
    <               reduce using rule 65 (expression -> expression GE expression .)
    LE              reduce using rule 65 (expression -> expression GE expression .)
    GE              reduce using rule 65 (expression -> expression GE expression .)
    ;               reduce using rule 65 (expression -> expression GE expression .)
    )               reduce using rule 65 (expression -> expression GE expression .)
    ,               reduce using rule 65 (expression -> expression GE expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    SHL             shift and go to state 59
    SHR             shift and go to state 55

  ! +               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! -               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! *               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! /               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! %               [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! SHL             [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! SHR             [ reduce using rule 65 (expression -> expression GE expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 111

    (52) expression -> expression % expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    +               reduce using rule 52 (expression -> expression % expression .)
    -               reduce using rule 52 (expression -> expression % expression .)
    *               reduce using rule 52 (expression -> expression % expression .)
    /               reduce using rule 52 (expression -> expression % expression .)
    %               reduce using rule 52 (expression -> expression % expression .)
    |               reduce using rule 52 (expression -> expression % expression .)
    &               reduce using rule 52 (expression -> expression % expression .)
    ^               reduce using rule 52 (expression -> expression % expression .)
    AND             reduce using rule 52 (expression -> expression % expression .)
    OR              reduce using rule 52 (expression -> expression % expression .)
    SHL             reduce using rule 52 (expression -> expression % expression .)
    SHR             reduce using rule 52 (expression -> expression % expression .)
    EQ              reduce using rule 52 (expression -> expression % expression .)
    NEQ             reduce using rule 52 (expression -> expression % expression .)
    >               reduce using rule 52 (expression -> expression % expression .)
    <               reduce using rule 52 (expression -> expression % expression .)
    LE              reduce using rule 52 (expression -> expression % expression .)
    GE              reduce using rule 52 (expression -> expression % expression .)
    ;               reduce using rule 52 (expression -> expression % expression .)
    )               reduce using rule 52 (expression -> expression % expression .)
    ,               reduce using rule 52 (expression -> expression % expression .)

  ! +               [ shift and go to state 60 ]
  ! -               [ shift and go to state 62 ]
  ! *               [ shift and go to state 61 ]
  ! /               [ shift and go to state 63 ]
  ! %               [ shift and go to state 68 ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! SHL             [ shift and go to state 59 ]
  ! SHR             [ shift and go to state 55 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 112

    (61) expression -> expression NEQ expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 61 (expression -> expression NEQ expression .)
    &               reduce using rule 61 (expression -> expression NEQ expression .)
    ^               reduce using rule 61 (expression -> expression NEQ expression .)
    AND             reduce using rule 61 (expression -> expression NEQ expression .)
    OR              reduce using rule 61 (expression -> expression NEQ expression .)
    EQ              reduce using rule 61 (expression -> expression NEQ expression .)
    NEQ             reduce using rule 61 (expression -> expression NEQ expression .)
    >               reduce using rule 61 (expression -> expression NEQ expression .)
    <               reduce using rule 61 (expression -> expression NEQ expression .)
    LE              reduce using rule 61 (expression -> expression NEQ expression .)
    GE              reduce using rule 61 (expression -> expression NEQ expression .)
    ;               reduce using rule 61 (expression -> expression NEQ expression .)
    )               reduce using rule 61 (expression -> expression NEQ expression .)
    ,               reduce using rule 61 (expression -> expression NEQ expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    SHL             shift and go to state 59
    SHR             shift and go to state 55

  ! +               [ reduce using rule 61 (expression -> expression NEQ expression .) ]
  ! -               [ reduce using rule 61 (expression -> expression NEQ expression .) ]
  ! *               [ reduce using rule 61 (expression -> expression NEQ expression .) ]
  ! /               [ reduce using rule 61 (expression -> expression NEQ expression .) ]
  ! %               [ reduce using rule 61 (expression -> expression NEQ expression .) ]
  ! SHL             [ reduce using rule 61 (expression -> expression NEQ expression .) ]
  ! SHR             [ reduce using rule 61 (expression -> expression NEQ expression .) ]
  ! |               [ shift and go to state 71 ]
  ! &               [ shift and go to state 57 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]
  ! EQ              [ shift and go to state 65 ]
  ! NEQ             [ shift and go to state 70 ]
  ! >               [ shift and go to state 66 ]
  ! <               [ shift and go to state 58 ]
  ! LE              [ shift and go to state 56 ]
  ! GE              [ shift and go to state 67 ]


state 113

    (53) expression -> expression | expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 53 (expression -> expression | expression .)
    AND             reduce using rule 53 (expression -> expression | expression .)
    OR              reduce using rule 53 (expression -> expression | expression .)
    ;               reduce using rule 53 (expression -> expression | expression .)
    )               reduce using rule 53 (expression -> expression | expression .)
    ,               reduce using rule 53 (expression -> expression | expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    &               shift and go to state 57
    ^               shift and go to state 72
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67

  ! +               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! -               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! *               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! /               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! %               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! &               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! ^               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! SHL             [ reduce using rule 53 (expression -> expression | expression .) ]
  ! SHR             [ reduce using rule 53 (expression -> expression | expression .) ]
  ! EQ              [ reduce using rule 53 (expression -> expression | expression .) ]
  ! NEQ             [ reduce using rule 53 (expression -> expression | expression .) ]
  ! >               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! <               [ reduce using rule 53 (expression -> expression | expression .) ]
  ! LE              [ reduce using rule 53 (expression -> expression | expression .) ]
  ! GE              [ reduce using rule 53 (expression -> expression | expression .) ]
  ! |               [ shift and go to state 71 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]


state 114

    (55) expression -> expression ^ expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    |               reduce using rule 55 (expression -> expression ^ expression .)
    ^               reduce using rule 55 (expression -> expression ^ expression .)
    AND             reduce using rule 55 (expression -> expression ^ expression .)
    OR              reduce using rule 55 (expression -> expression ^ expression .)
    ;               reduce using rule 55 (expression -> expression ^ expression .)
    )               reduce using rule 55 (expression -> expression ^ expression .)
    ,               reduce using rule 55 (expression -> expression ^ expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    &               shift and go to state 57
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67

  ! +               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! -               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! *               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! /               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! %               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! &               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! SHL             [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! SHR             [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! EQ              [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! NEQ             [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! >               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! <               [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! LE              [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! GE              [ reduce using rule 55 (expression -> expression ^ expression .) ]
  ! |               [ shift and go to state 71 ]
  ! ^               [ shift and go to state 72 ]
  ! AND             [ shift and go to state 54 ]
  ! OR              [ shift and go to state 64 ]


state 115

    (35) while_instr -> WHILE ( condition ) . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 132
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 7
    break_instr                    shift and go to state 2
    while_instr                    shift and go to state 10

state 116

    (36) while_instr -> WHILE ( error ) . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 133
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    while_instr                    shift and go to state 10
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 2
    labeled_instr                  shift and go to state 14
    repeat_instr                   shift and go to state 7

state 117

    (37) repeat_instr -> REPEAT instructions UNTIL condition . ;

    ;               shift and go to state 134


state 118

    (30) assignment -> ID = expression ; .

    TYPE            reduce using rule 30 (assignment -> ID = expression ; .)
    error           reduce using rule 30 (assignment -> ID = expression ; .)
    PRINT           reduce using rule 30 (assignment -> ID = expression ; .)
    ID              reduce using rule 30 (assignment -> ID = expression ; .)
    IF              reduce using rule 30 (assignment -> ID = expression ; .)
    WHILE           reduce using rule 30 (assignment -> ID = expression ; .)
    REPEAT          reduce using rule 30 (assignment -> ID = expression ; .)
    RETURN          reduce using rule 30 (assignment -> ID = expression ; .)
    BREAK           reduce using rule 30 (assignment -> ID = expression ; .)
    CONTINUE        reduce using rule 30 (assignment -> ID = expression ; .)
    {               reduce using rule 30 (assignment -> ID = expression ; .)
    $end            reduce using rule 30 (assignment -> ID = expression ; .)
    UNTIL           reduce using rule 30 (assignment -> ID = expression ; .)
    }               reduce using rule 30 (assignment -> ID = expression ; .)
    ELSE            reduce using rule 30 (assignment -> ID = expression ; .)


state 119

    (31) choice_instr -> IF ( condition ) . instruction
    (32) choice_instr -> IF ( condition ) . instruction ELSE instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 135
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 7
    break_instr                    shift and go to state 2
    while_instr                    shift and go to state 10

state 120

    (33) choice_instr -> IF ( error ) . instruction
    (34) choice_instr -> IF ( error ) . instruction ELSE instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 136
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    while_instr                    shift and go to state 10
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 2
    labeled_instr                  shift and go to state 14
    repeat_instr                   shift and go to state 7

state 121

    (41) compound_instr -> { declarations instructions } .

    TYPE            reduce using rule 41 (compound_instr -> { declarations instructions } .)
    error           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    PRINT           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    ID              reduce using rule 41 (compound_instr -> { declarations instructions } .)
    IF              reduce using rule 41 (compound_instr -> { declarations instructions } .)
    WHILE           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    REPEAT          reduce using rule 41 (compound_instr -> { declarations instructions } .)
    RETURN          reduce using rule 41 (compound_instr -> { declarations instructions } .)
    BREAK           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    CONTINUE        reduce using rule 41 (compound_instr -> { declarations instructions } .)
    {               reduce using rule 41 (compound_instr -> { declarations instructions } .)
    $end            reduce using rule 41 (compound_instr -> { declarations instructions } .)
    UNTIL           reduce using rule 41 (compound_instr -> { declarations instructions } .)
    }               reduce using rule 41 (compound_instr -> { declarations instructions } .)
    ELSE            reduce using rule 41 (compound_instr -> { declarations instructions } .)


state 122

    (14) init -> ID . = expression

    =               shift and go to state 90


state 123

    (12) inits -> inits , init .

    ;               reduce using rule 12 (inits -> inits , init .)
    ,               reduce using rule 12 (inits -> inits , init .)


state 124

    (75) args_list_or_empty -> args_list .
    (77) args_list -> args_list . , arg

    )               reduce using rule 75 (args_list_or_empty -> args_list .)
    ,               shift and go to state 137


state 125

    (74) fundef -> TYPE ID ( args_list_or_empty . ) compound_instr

    )               shift and go to state 138


state 126

    (78) args_list -> arg .

    ,               reduce using rule 78 (args_list -> arg .)
    )               reduce using rule 78 (args_list -> arg .)


state 127

    (79) arg -> TYPE . ID

    ID              shift and go to state 139


state 128

    (14) init -> ID = expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    ;               reduce using rule 14 (init -> ID = expression .)
    ,               reduce using rule 14 (init -> ID = expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 129

    (72) expr_list -> expr_list , . expression
    (46) expression -> . ID
    (47) expression -> . const
    (48) expression -> . expression + expression
    (49) expression -> . expression - expression
    (50) expression -> . expression * expression
    (51) expression -> . expression / expression
    (52) expression -> . expression % expression
    (53) expression -> . expression | expression
    (54) expression -> . expression & expression
    (55) expression -> . expression ^ expression
    (56) expression -> . expression AND expression
    (57) expression -> . expression OR expression
    (58) expression -> . expression SHL expression
    (59) expression -> . expression SHR expression
    (60) expression -> . expression EQ expression
    (61) expression -> . expression NEQ expression
    (62) expression -> . expression > expression
    (63) expression -> . expression < expression
    (64) expression -> . expression LE expression
    (65) expression -> . expression GE expression
    (66) expression -> . ( expression )
    (67) expression -> . ( error )
    (68) expression -> . ID ( expr_list_or_empty )
    (69) expression -> . ID ( error )
    (43) const -> . INTEGER
    (44) const -> . FLOAT
    (45) const -> . STRING

    ID              shift and go to state 31
    (               shift and go to state 33
    INTEGER         shift and go to state 29
    FLOAT           shift and go to state 32
    STRING          shift and go to state 30

    expression                     shift and go to state 140
    const                          shift and go to state 28

state 130

    (68) expression -> ID ( expr_list_or_empty ) .

    +               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    -               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    *               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    /               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    %               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    |               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    &               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    ^               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    AND             reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    OR              reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    SHL             reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    SHR             reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    EQ              reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    NEQ             reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    >               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    <               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    LE              reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    GE              reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    ;               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    )               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)
    ,               reduce using rule 68 (expression -> ID ( expr_list_or_empty ) .)


state 131

    (69) expression -> ID ( error ) .

    +               reduce using rule 69 (expression -> ID ( error ) .)
    -               reduce using rule 69 (expression -> ID ( error ) .)
    *               reduce using rule 69 (expression -> ID ( error ) .)
    /               reduce using rule 69 (expression -> ID ( error ) .)
    %               reduce using rule 69 (expression -> ID ( error ) .)
    |               reduce using rule 69 (expression -> ID ( error ) .)
    &               reduce using rule 69 (expression -> ID ( error ) .)
    ^               reduce using rule 69 (expression -> ID ( error ) .)
    AND             reduce using rule 69 (expression -> ID ( error ) .)
    OR              reduce using rule 69 (expression -> ID ( error ) .)
    SHL             reduce using rule 69 (expression -> ID ( error ) .)
    SHR             reduce using rule 69 (expression -> ID ( error ) .)
    EQ              reduce using rule 69 (expression -> ID ( error ) .)
    NEQ             reduce using rule 69 (expression -> ID ( error ) .)
    >               reduce using rule 69 (expression -> ID ( error ) .)
    <               reduce using rule 69 (expression -> ID ( error ) .)
    LE              reduce using rule 69 (expression -> ID ( error ) .)
    GE              reduce using rule 69 (expression -> ID ( error ) .)
    ;               reduce using rule 69 (expression -> ID ( error ) .)
    )               reduce using rule 69 (expression -> ID ( error ) .)
    ,               reduce using rule 69 (expression -> ID ( error ) .)


state 132

    (35) while_instr -> WHILE ( condition ) instruction .

    TYPE            reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    error           reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    PRINT           reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    ID              reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    IF              reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    WHILE           reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    REPEAT          reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    RETURN          reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    BREAK           reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    CONTINUE        reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    {               reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    $end            reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    UNTIL           reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    }               reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)
    ELSE            reduce using rule 35 (while_instr -> WHILE ( condition ) instruction .)


state 133

    (36) while_instr -> WHILE ( error ) instruction .

    TYPE            reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    error           reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    PRINT           reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    ID              reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    IF              reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    WHILE           reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    REPEAT          reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    RETURN          reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    BREAK           reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    CONTINUE        reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    {               reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    $end            reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    UNTIL           reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    }               reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)
    ELSE            reduce using rule 36 (while_instr -> WHILE ( error ) instruction .)


state 134

    (37) repeat_instr -> REPEAT instructions UNTIL condition ; .

    UNTIL           reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    PRINT           reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    ID              reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    IF              reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    WHILE           reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    REPEAT          reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    RETURN          reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    BREAK           reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    CONTINUE        reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    {               reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    TYPE            reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    error           reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    $end            reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    }               reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)
    ELSE            reduce using rule 37 (repeat_instr -> REPEAT instructions UNTIL condition ; .)


state 135

    (31) choice_instr -> IF ( condition ) instruction .
    (32) choice_instr -> IF ( condition ) instruction . ELSE instruction

    TYPE            reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    error           reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    PRINT           reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    ID              reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    IF              reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    WHILE           reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    REPEAT          reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    RETURN          reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    BREAK           reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    CONTINUE        reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    {               reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    $end            reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    UNTIL           reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    }               reduce using rule 31 (choice_instr -> IF ( condition ) instruction .)
    ELSE            shift and go to state 141

  ! ELSE            [ reduce using rule 31 (choice_instr -> IF ( condition ) instruction .) ]


state 136

    (33) choice_instr -> IF ( error ) instruction .
    (34) choice_instr -> IF ( error ) instruction . ELSE instruction

    TYPE            reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    error           reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    PRINT           reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    ID              reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    IF              reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    WHILE           reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    REPEAT          reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    RETURN          reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    BREAK           reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    CONTINUE        reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    {               reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    $end            reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    UNTIL           reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    }               reduce using rule 33 (choice_instr -> IF ( error ) instruction .)
    ELSE            shift and go to state 142

  ! ELSE            [ reduce using rule 33 (choice_instr -> IF ( error ) instruction .) ]


state 137

    (77) args_list -> args_list , . arg
    (79) arg -> . TYPE ID

    TYPE            shift and go to state 127

    arg                            shift and go to state 143

state 138

    (74) fundef -> TYPE ID ( args_list_or_empty ) . compound_instr
    (41) compound_instr -> . { declarations instructions }

    {               shift and go to state 26

    compound_instr                 shift and go to state 144

state 139

    (79) arg -> TYPE ID .

    ,               reduce using rule 79 (arg -> TYPE ID .)
    )               reduce using rule 79 (arg -> TYPE ID .)


state 140

    (72) expr_list -> expr_list , expression .
    (48) expression -> expression . + expression
    (49) expression -> expression . - expression
    (50) expression -> expression . * expression
    (51) expression -> expression . / expression
    (52) expression -> expression . % expression
    (53) expression -> expression . | expression
    (54) expression -> expression . & expression
    (55) expression -> expression . ^ expression
    (56) expression -> expression . AND expression
    (57) expression -> expression . OR expression
    (58) expression -> expression . SHL expression
    (59) expression -> expression . SHR expression
    (60) expression -> expression . EQ expression
    (61) expression -> expression . NEQ expression
    (62) expression -> expression . > expression
    (63) expression -> expression . < expression
    (64) expression -> expression . LE expression
    (65) expression -> expression . GE expression

    ,               reduce using rule 72 (expr_list -> expr_list , expression .)
    )               reduce using rule 72 (expr_list -> expr_list , expression .)
    +               shift and go to state 60
    -               shift and go to state 62
    *               shift and go to state 61
    /               shift and go to state 63
    %               shift and go to state 68
    |               shift and go to state 71
    &               shift and go to state 57
    ^               shift and go to state 72
    AND             shift and go to state 54
    OR              shift and go to state 64
    SHL             shift and go to state 59
    SHR             shift and go to state 55
    EQ              shift and go to state 65
    NEQ             shift and go to state 70
    >               shift and go to state 66
    <               shift and go to state 58
    LE              shift and go to state 56
    GE              shift and go to state 67


state 141

    (32) choice_instr -> IF ( condition ) instruction ELSE . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 145
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    labeled_instr                  shift and go to state 14
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    repeat_instr                   shift and go to state 7
    break_instr                    shift and go to state 2
    while_instr                    shift and go to state 10

state 142

    (34) choice_instr -> IF ( error ) instruction ELSE . instruction
    (17) instruction -> . print_instr
    (18) instruction -> . labeled_instr
    (19) instruction -> . assignment
    (20) instruction -> . choice_instr
    (21) instruction -> . while_instr
    (22) instruction -> . repeat_instr
    (23) instruction -> . return_instr
    (24) instruction -> . break_instr
    (25) instruction -> . continue_instr
    (26) instruction -> . compound_instr
    (27) print_instr -> . PRINT expression ;
    (28) print_instr -> . PRINT error ;
    (29) labeled_instr -> . ID : instruction
    (30) assignment -> . ID = expression ;
    (31) choice_instr -> . IF ( condition ) instruction
    (32) choice_instr -> . IF ( condition ) instruction ELSE instruction
    (33) choice_instr -> . IF ( error ) instruction
    (34) choice_instr -> . IF ( error ) instruction ELSE instruction
    (35) while_instr -> . WHILE ( condition ) instruction
    (36) while_instr -> . WHILE ( error ) instruction
    (37) repeat_instr -> . REPEAT instructions UNTIL condition ;
    (38) return_instr -> . RETURN expression ;
    (40) break_instr -> . BREAK ;
    (39) continue_instr -> . CONTINUE ;
    (41) compound_instr -> . { declarations instructions }

    PRINT           shift and go to state 5
    ID              shift and go to state 17
    IF              shift and go to state 18
    WHILE           shift and go to state 6
    REPEAT          shift and go to state 12
    RETURN          shift and go to state 1
    BREAK           shift and go to state 22
    CONTINUE        shift and go to state 24
    {               shift and go to state 26

    return_instr                   shift and go to state 8
    assignment                     shift and go to state 13
    instruction                    shift and go to state 146
    compound_instr                 shift and go to state 15
    continue_instr                 shift and go to state 9
    while_instr                    shift and go to state 10
    print_instr                    shift and go to state 23
    choice_instr                   shift and go to state 3
    break_instr                    shift and go to state 2
    labeled_instr                  shift and go to state 14
    repeat_instr                   shift and go to state 7

state 143

    (77) args_list -> args_list , arg .

    ,               reduce using rule 77 (args_list -> args_list , arg .)
    )               reduce using rule 77 (args_list -> args_list , arg .)


state 144

    (74) fundef -> TYPE ID ( args_list_or_empty ) compound_instr .

    TYPE            reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    error           reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    PRINT           reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    ID              reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    IF              reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    WHILE           reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    REPEAT          reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    RETURN          reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    BREAK           reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    CONTINUE        reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    {               reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)
    $end            reduce using rule 74 (fundef -> TYPE ID ( args_list_or_empty ) compound_instr .)


state 145

    (32) choice_instr -> IF ( condition ) instruction ELSE instruction .

    TYPE            reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    error           reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    PRINT           reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ID              reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    IF              reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    WHILE           reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    REPEAT          reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    RETURN          reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    BREAK           reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    {               reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    $end            reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    UNTIL           reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    }               reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)
    ELSE            reduce using rule 32 (choice_instr -> IF ( condition ) instruction ELSE instruction .)


state 146

    (34) choice_instr -> IF ( error ) instruction ELSE instruction .

    TYPE            reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    error           reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    PRINT           reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ID              reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    IF              reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    WHILE           reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    REPEAT          reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    RETURN          reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    BREAK           reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    CONTINUE        reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    {               reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    $end            reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    UNTIL           reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    }               reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)
    ELSE            reduce using rule 34 (choice_instr -> IF ( error ) instruction ELSE instruction .)

